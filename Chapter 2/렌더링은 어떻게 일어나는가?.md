# 2.4 렌더링은 어떻게 일어나는가

## 👉 서론

프론트엔드에서 "렌더링"이란 용어를 들었을 때 보통 브라우저의 렌더링을 생각할 것이다.
브라우저의 렌더링은, `HTML`, `CSS` 리소스를 기반으로 UI를 그리는 과정을 의미한다.

리액트에서도 렌더링이라는 과정이 존재한다.
리액트의 렌더링은 브라우저가 렌더링에 필요한 `DOM` 트리를 그리는 과정을 의미한다.
리액트 또한 브라우저와 마찬가지로 렌더링 작업을 위한 자체 렌더링 프로세스 존재. 이를 이해하는 것이 중요하다.

### 👉 리액트의 렌더링이란 ?

리액트의 렌더링이란,

리액트 어플리케이션 컴포넌트 트리 안에 있는 모든 컴포넌트들이 자신의 `state`, `props`를 기반으로 어떻게 UI를 구성하고,
이를 바탕으로 어떤 `DOM` 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

컴포넌트가 `props`, `state`를 가지고 있지 않다면 오직 해당 컴포넌트가 반환하는 `JSX` 값에 기반하여 렌더링한다.

### 👉 리액트의 렌더링이 일어나는 이유

렌더링 과정을 이해하기 앞서 렌더링이 "언제" 발생하는지 아는 것이 중요하다. 렌더링 시나리오는 다음과 같다.

1. 최초 렌더링
   사용자가 처음 app에 진입하면 당연히 렌더링해야 할 결과물이 필요. 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링 수행
2. 리렌더링
   리렌더링은 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미. 리렌더링이 발생하는 경우는 다음과 같다.

- 함수형 컴포넌트의 `useState()` `setter`가 실행되는 경우
- 함수형 컴포넌트의 `useReducer()`의 `dispatch`가 실행되는 경우
- 컴포넌트의 `key props`가 변경되는 경우
- `props`가 변경되는 경우
- 부모 컴포넌트가 렌더링될 경우: **자식 컴포넌트**도 무조건 리렌더링. 이후에 자세히 다룬다.

#### 💡 key props

일반적으로 `key`는 다음과 같이 배열에서 하위 컴포넌트를 선언할 때 사용된다.
리액트에서 배열에 `key`를 사용하지 않으면 콘솔에 경고가 출력되는데, 왜 `key`가 필요한 것인가 ?

리액트에서 `key`는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다.
리액트 파이버 구조를 떠올려보면,
해당 트리 구조에서 형제 컴포넌트를 구별하기 위해 `sibling` 속성값을 사용하였다.
리렌더링이 발생하면 `current` 트리와 `workInProgress` 트리 사이에서 어떠한 컴포넌트 변경이 있었는지 구별해야 하는데,
이 두 트리 사이에서 같은 컴포넌트를 구별하는 값이 바로 `key`인 것이다.
이 변경 사항을 구별하는 작업은 **"리렌더링이 필요한 컴포넌트를 최소화"**해야 하므로 반드시 필요하다.
또한, `key`의 변화는 리렌더링을 야기한다. 이러한 특징을 이용하면 key를 활용해 강제로 리렌더링을 일으키는 것이 가능하다.

리액트에서 렌더링이 일어나는 경우는 위에 나열한 시나리오뿐이다.

### 👉 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면

1. 클래스형 컴포넌트의 경우 `render()` 함수 실행
2. 함수형 컴포넌트의 경우 `FunctionComponent()` 그 자체를 호출

한 뒤에, 그 결과물을 저장한다.

일반적으로, 렌더링 결과물은 `JSX` 문법으로 구성돼 있고, 이것이 자바스크립트로 컴파일되면서 `React.createElement()`를 호출하는 구문으로 변환된다.
여기서 `createElement`는 브라우저의 `UI` 구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환한다.

```javascript
function Hello() {
  return (
    <TestComponent a={35} b="yceffort">
      안녕하세요
    </TestComponent>
  );
}
```

위 JSX 문법은 다음과 같은 `React.createElement`를 호출해서 변환한다.

```javascript
function Hello() {
  return React.createElement(
    TestComponent,
    { a: 35, b: "yceffort" },
    "안녕하세요"
  );
}
```

결과물은 다음과 같다.

```javascript
{type: TestComponent, props: {a: 35, b: "yceffort", children: "안녕하세요"}}
```

렌더링 프로세스가 실행되면서 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집한다.
그 다음, 리액트의 새로운 트리인 "가상 DOM"과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.
이러한 계산 과정을 이전에 설명한 '리액트 파이버'에서 다뤘던 리액트의 재조정(`Reconciliation`)이라 한다.
이러한 재조정 과정이 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용하여 변경된 결과물이 보이게 된다.

여기서 주목할 점은, 리액트의 렌더링은 렌더 단계와 커밋 단계라는 총 두 단계로 분리되어 실행된다.

### 👉 렌더와 커밋

렌더 단계(`Render Phase`)는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.

- 즉, 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
- 비교하는 것은 크게 `type`, `props`, `key`

그 다음으로 커밋 단계(`Commit Phase`)는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정이다.

- 해당 과정을 거쳐야 비로소 브라우저의 렌더링이 발생.
- 리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면, 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트.
- 그 다음, 생명주기 개념이 있는 클래스형 컴포넌트에서는 `componentDidMount`, `componentDidUpdate` 메서드를 호출하며, 함수형 컴포넌트에서는 `useLayoutEffect` 훅을 호출.

중요한 점은,
**리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 것**이다.

렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면,
즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략 가능하다.
즉 리액트의 렌더링은 꼭 가시적인 변경이 일어나지 않아도 발생 가능

![](https://velog.velcdn.com/images/wuzoo/post/78528399-693e-4926-8784-2e0635b527d3/image.png)

---

이 렌더, 커밋 과정으로 이루어진 리액트의 렌더링은 항상 동기식으로 작동하였다.
렌더링 과정이 길어질수록 성능 저하로 이루어질 수 있다.

사실 렌더링 프로세스의 특징을 생각해보면 당연한 것이다.
순서가 보장되지 않는 비동기 방식으로 이루어질 경우, 사용자는 하나의 상태에 대해 여러 가지 다른 UI를 보게 될 것이다.
`A`라는 상태가 변경되면 각각 `B`와 `C`가 `B1`, `C1`이 되어야 하는데, A가 변경되었음에도 불구하고 하나의 컴포넌트가 뒤늦게 변경되어,
`B`, `C1`이 될 수도 있는 것이다. 이는 혼란을 야기할 수 있다.

하지만 이러한 비동기 렌더링 시나리오는 몇 가지 상황에서 유효할 수도 있다.

> `B`의 컴포넌트 렌더링 작업이 무거워 상대적으로 빠르게 렌더링할 수 있는 `C`라도 변경해서 보여줄 수 있다면 ?

이렇게 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, 이른바 동시성 렌더링이 리액트 18에서 도입.

### 👉 가장 일반적인 렌더링 시나리오

예제 리액트 코드를 살펴보면서 리액트의 렌더링이 어떻게 발생하는지 살펴보자.

```javascript
import { useState } from "react";

export default function A() {
  return (
    <div>
      <h1>Hello React !</h1>
      <B />
    </div>
  );
}

function B() {
  const [counter, setCounter] = useState(0);

  function handleButtonClick() {
    setCounter((prev) => prev + 1);
  }

  return (
    <>
      <label>
        <C number={counter} />
      </label>
      <button onClick={handleButtonClick}>+</button>
    </>
  );
}

function C({ number }) {
  return (
    <div>
      {number} <D />
    </div>
  );
}

function D() {
  return <>리액트 재밌다!</>;
}
```

다음의 A, B, C, D 컴포넌트가 있으며, 순서에 따라 부모와 자식 관계를 가지고 있는 일반적인 리액트 웹 애플리케이션의 모습을 띠고 있다.
그리고 사용자가 B 컴포넌트의 버튼을 눌러 `counter` 변수를 업데이트한다고 가정해 보자.
그렇다면 리액트는 다음과 같은 순서로 렌더링을 진행한다.

1. B의 `setState`가 호출
2. B의 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어간다.
3. 리액트는 트리 최상단부터 렌더링 경로 검사
4. A 컴포넌트는 리렌더링이 필요한 변경된 컴포넌트로 표시돼 있지 않으므로 작업 x
5. 그 다음 하위 컴포넌트 B 컴포넌트는 업데이트가 필요하다고 체크돼 있으므로 B를 리렌더링
6. 5번 과정에서 B는 C를 반환
7. C는 `props`인 `number`가 업데이트됐으므로, 업데이트가 필요한 컴포넌트로 체크돼 있고 업데이트 수행
8. 7번 과정에서 C는 D를 반환
9. D도 마찬가지로 업데이트가 필요한 컴포넌트로 체크되지 않았지만, C가 렌더링됐으므로 자식인 D도 렌더링된다.

컴포넌트를 렌더링하는 작업은 별도로 렌더링을 피하기 위한 조치가 돼있지 않는 한 모든 하위 컴포넌트에 영향을 미친다.
상위 컴포넌트, 특히 루트에서 무언가 렌더링을 발생시키는 작업이 일어나는 것은 하위 모든 컴포넌트의 리렌더링을 트리거할 수 있다.

이는 `memo`를 통해 `props`가 변경되지 않는 한 상위 컴포넌트에서의 렌더링이 자신 컴포넌트에 영향을 미치지 않게 할 수 있다.
